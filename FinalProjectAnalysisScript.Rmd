---
title: "FinalProjectAnalysisScript"
author: "Dun Fletcher Lin"
date: "2025-02-22"
output: html_document
---

### Import libraries

```{r}
library(printr) # Package used for printing out the documentation of function in the output

library(grDevices) # Package used for plotting out time series

library(tseries) # Package for Time series analysis and computational finance

library(graphics)

library(utils)

library(stats) # Package used for statistical calculations and random number generations

library(forecast) # Package used for functions that could be used for creating forecast including seasonality plot

library(ggplot2) # Package used for plotting out the the dataset
```

-----

### 1. Introduction: Includes problem statement and objective of your project.

-----

### 2. Data: Elaborate on the data used in this project with detailed description of all attributes, source of data, missing observations, etc. Describe any steps you followed to prepare the data.

#### Data Description

#### Data Source

#### Load in data

Read in file from .csv
```{r}
cyber_data <- read.csv(file = "./information-2897447-supplementary/cyber_data.csv")
```

#### Examine attributes of the data

Examine attributes of data
```{r}
numberOfColumns <- ncol(cyber_data)
cat(c('There are ', numberOfColumns, 'columns in the dataset'))
numberOfObservations <- nrow(cyber_data)
cat(c('There are', numberOfObservations, 'observations in the dataset'))
```

#### Missing observations

Generate a table which print out the following structure
columnName, hasNA, numberOfNA
```{r}
maximumLengthOfColumnName <- max(nchar(names(cyber_data)))

cat("******************\n")
cat("Summary table for missing observations: \n")
cat(c("columnName", strrep(' ', maximumLengthOfColumnName - 10), '| hasNA', ' | numberOfNA\n'))
for (column in colnames(cyber_data)) {
  hasNA <- sum(is.na(cyber_data[column])) > 0
  numberOfNA <- sum(is.na(cyber_data[column]))
  if (hasNA) {
    cat(c(column, 
          strrep(' ', maximumLengthOfColumnName - nchar(column) + 2), 
          paste('|', hasNA), 
          '   | ', 
          numberOfNA, 
          '\n'), 
        sep = '')
  }
  else {
    cat(c(column, 
          strrep(' ', maximumLengthOfColumnName - nchar(column) + 2), 
          paste('|', hasNA), 
          '  | ', 
          numberOfNA, 
          '\n'), 
        sep = '')
  }
}
cat("******************")
```

#### Data Preparation

Convert `AttackDate` to be a date time column
```{r}
cyber_data$ConvertedAttackDateTime <- as.POSIXct(cyber_data$AttackDate, format = "%d/%m/%Y %H:%M")
```

Re-code `ConvertedAttackDateTime` time as original recording time should be 6:00 a.m. every morning
```{r}
cyber_data$ConvertedAttackDateTime <- as.POSIXct(format(cyber_data$ConvertedAttackDateTime, "%Y-%m-%d 06:00:00"))
```

Separate `ConvertedAttackDateTime` to be 2 columns: ConvertedAttackDate, ConvertedAttackTime
```{r}
cyber_data$ConvertedAttackDate <- as.Date(cyber_data$ConvertedAttackDateTime)

cyber_data$ConvertedAttackTime <- format(cyber_data$ConvertedAttackDateTime, format = "%H:%M")
```

Create dummy code for the `Country` column 
```{r}
# Perform dummy coding
dummy_coded_country <- model.matrix(~ Country - 1, cyber_data)

# Convert the dummy-coded matrix to a dataframe
dummy_coded_country_df <- as.data.frame(dummy_coded_country)

# Add the dummy-coded columns back to the original dataframe
cyber_data <- cbind(cyber_data, dummy_coded_country_df)
```

#### Data Exploration

Identify the time range that I am working with
```{r}
min_date <- min(cyber_data$ConvertedAttackDate)
cat(c('The initial date examined is', as.character(min_date), '\n'))

max_date <- max(cyber_data$ConvertedAttackDate)
cat(c('The final date examined is', as.character(max_date), '\n'))

frequency_of_reading <- (max_date - min_date) / length(unique(cyber_data$ConvertedAttackDate))
cat(c('The frequency of reading is ', frequency_of_reading, '\n'))
```

Since the frequency of reading does not equal to 1 exactly, that means that there are particular days in which data record was omitted or missed. For simplicity and completeness sake, I will go ahead and create entries for those days with NA values to the original dataset.

Identify the missing dates
```{r}
all_dates <- seq(min_date, max_date, by = "day")
missing_dates <- all_dates[!all_dates %in% unique(cyber_data$ConvertedAttackDate)]
print(missing_dates)
```

Add in rows of data for missing dates
```{r}
cat(c('Creating', length(missing_dates), 'date record for simplicity and completeness'))

# Add the time part and convert each date string to POSIXct with PDT timezone
missing_datetime_list <- sapply(missing_dates, function(date_str) {
  datetime_str <- paste(date_str, "06:00:00") # Force the time for the rows to be 06:00
  datetime_obj <- as.POSIXct(datetime_str, format="%Y-%m-%d %H:%M:%S", tz="America/Los_Angeles")
  formatted_datetime <- format(datetime_obj, "%Y-%m-%d %H:%M:%S %Z")
  return(formatted_datetime)
})

# New row with only column A having a value
new_rows <- sapply(cyber_data, function(x) {
  if (inherits(x, "POSIXct")) {
    missing_datetime_list  # Replace with the desired value for column ConvertedAttackDateTime
  } else if (class(x) == "Date") {
    missing_dates
  } else {
    NA  # For other columns (numeric, logical, etc.), fill with NA
  }
})

# Convert the result to a data frame and set the column names
new_rows <- as.data.frame(new_rows)
colnames(new_rows) <- colnames(new_rows)

# Use rbind to add the new row
cyber_data <- rbind(cyber_data, new_rows)
```



-----

### 3. Experimental results and Analysis: Execute algorithm (plots, ACF, PACF, Spectral Analysis, hypothesis testing, etc.), discuss results with appropriate details.

#### Initial Plot

#### ACF

#### PACF

-----

### 4. Model Selection: Select final model based on selection criteria and evaluate forecasting metrics and accuracy.


#### Final Model

#### Forecasting Metrics

#### Accuracy

-----

### 5. Conclusion and Future work: Summarize your work and draw specific conclusions from the overall final project. Describe next steps to continue working on this project. (i.e., how the model forecasting can be improved)

-----

### Cleanup task

Cleanup the variables that are defined in the environment
```{r}
rm(list = ls())
```